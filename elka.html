   <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Christmas tree</title>
   
</head>
<body>
    <canvas id="tree" width="2000" height="1000">
        <p>Ваш браузер не поддерживает рисование.</p>
    </canvas>
</body>
</html>

<script type="text/javascript">

window.onload = function() {

  var drawingCanvas = document.getElementById('tree');
  var ctx = drawingCanvas.getContext('2d');


  const NodeCount = 10;
  
  const  mainRootPos = [500, 900];
  const  mainRootLength = 600;
  const  mainRootAngle = -Math.PI/2;  
  const  depthConst = 3;

  var ballsPositions = [];
  makeBalls();

/*

// elements for obtaining vals
var val1El = document.getElementById('color1');
var val2El = document.getElementById('color2');
var stepsEl = document.getElementById('steps');

// constants for switch/case checking representation type
const HEX = 1;
const RGB = 2;
const RGBA = 3;

// get the string representation 
// type and set it on the element (HEX/RGB/RGBA)
function getType(val) {
  if (val.indexOf('#') > -1) return HEX;
  if (val.indexOf('rgb(') > -1) return RGB;
  if (val.indexOf('rgba(') > -1) return RGBA;
}

// process the value irrespective of representation type
function processValue(el) {
  switch (el.dataType) {
    case HEX:
      {
        return processHEX(el.value);
      }
    case RGB:{
      return processRGB(el.value);
    }
    case RGBA:{
      return processRGB(el.value);
    }
      
  }
}

//return a workable RGB int array [r,g,b] from rgb/rgba representation
function processRGB(val){
  var rgb = val.split('(')[1].split(')')[0].split(',');
  alert(rgb.toString());
  return [
      parseInt(rgb[0],10),
      parseInt(rgb[1],10),
      parseInt(rgb[2],10)
  ];
}

//return a workable RGB int array [r,g,b] from hex representation
function processHEX(val) {
  //does the hex contain extra char?
  var hex = (val.length >6)?val.substr(1, val.length - 1):val;
  // is it a six character hex?
  if (hex.length > 3) {

    //scrape out the numerics
    var r = hex.substr(0, 2);
    var g = hex.substr(2, 2);
    var b = hex.substr(4, 2);

    // if not six character hex,
    // then work as if its a three character hex
  } else {

    // just concat the pieces with themselves
    var r = hex.substr(0, 1) + hex.substr(0, 1);
    var g = hex.substr(1, 1) + hex.substr(1, 1);
    var b = hex.substr(2, 1) + hex.substr(2, 1);

  }
  // return our clean values
    return [
      parseInt(r, 16),
      parseInt(g, 16),
      parseInt(b, 16)
    ]
}

function updateSpitter() {
    //attach start value
    var hasSpun = 0;
    val1El.dataType = getType(val1El.value);
    val2El.dataType = getType(val2El.value);

    var val1RGB = processValue(val1El);
    var val2RGB = processValue(val2El);
    var colors = [
      // somewhere to dump gradient
    ];
    // the pre element where we spit array to user
    var spitter = document.getElementById('spitter');

    //the number of steps in the gradient
    var stepsInt = parseInt(steps.value, 10);
    //the percentage representation of the step
    var stepsPerc = 100 / (stepsInt+1);

    // diffs between two values 
    var valClampRGB = [
      val2RGB[0] - val1RGB[0],
      val2RGB[1] - val1RGB[1],
      val2RGB[2] - val1RGB[2]
    ];
  
    // build the color array out with color steps
    for (var i = 0; i < stepsInt; i++) {
      var clampedR = (valClampRGB[0] > 0) 
      ? pad((Math.round(valClampRGB[0] / 100 * (stepsPerc * (i + 1)))).toString(16), 2) 
      : pad((Math.round((val1RGB[0] + (valClampRGB[0]) / 100 * (stepsPerc * (i + 1))))).toString(16), 2);
      
      var clampedG = (valClampRGB[1] > 0) 
      ? pad((Math.round(valClampRGB[1] / 100 * (stepsPerc * (i + 1)))).toString(16), 2) 
      : pad((Math.round((val1RGB[1] + (valClampRGB[1]) / 100 * (stepsPerc * (i + 1))))).toString(16), 2);
      
      var clampedB = (valClampRGB[2] > 0) 
      ? pad((Math.round(valClampRGB[2] / 100 * (stepsPerc * (i + 1)))).toString(16), 2) 
      : pad((Math.round((val1RGB[2] + (valClampRGB[2]) / 100 * (stepsPerc * (i + 1))))).toString(16), 2);
      colors[i] = [
        '#',
        clampedR,
        clampedG,
        clampedB
      ].join('');
    }
  //build div representation of gradient
  var html = [];
    for(var i = 0;i<colors.length;i++){
      html.push("<div class='color' style='background-color:"+colors[i]+"; height:"+((i-(i-1))/colors.length*100)+"%;'></div>");
    }
 document.getElementById("colors").innerHTML = html.join('');
    //update the pre element
    spitter.innerText = JSON.stringify(colors);
  }
  /**
   * padding function:
   * cba to roll my own, thanks Pointy!
   * ==================================
   * source: http://stackoverflow.com/questions/10073699/pad-a-number-with-leading-zeros-in-javascript
   */

  /*
function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}
updateSpitter();

*/





function getGreenToRed(percent){

//rgb(0,100,0) green
//rgb(139,69,19) brown

    R = percent<50 ? 255 : Math.floor(255-(percent*2-100)*255/100);
    G = percent>50 ? 255 : Math.floor((percent*2)*255/100);
    B = 0;

    var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

    return "#"+RR+GG+BB;
}


function getBrownToGreen(depth){
    console.log(depth, ["#175f03","#2e5a06","#46550a","#5d4f0d","#744a10"].reverse()[depth])
    return ["#175f03","#2e5a06","#46550a","#5d4f0d","#744a10"].reverse()[depth];

}







function shadeColor(color, percent) {

    var R = parseInt(color.substring(1,3),16);
    var G = parseInt(color.substring(3,5),16);
    var B = parseInt(color.substring(5,7),16);

    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);

    R = (R<255)?R:255;  
    G = (G<255)?G:255;  
    B = (B<255)?B:255;  

    var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
    var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
    var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));

    return "#"+RR+GG+BB;
}
      
function drawStar(cx,cy,spikes,outerRadius,innerRadius){
  var rot=Math.PI/2*3;
  var x=cx;
  var y=cy;
  var step=Math.PI/spikes;

  ctx.beginPath();
  ctx.moveTo(cx,cy-outerRadius)
  for(i=0;i<spikes;i++){
    x=cx+Math.cos(rot)*outerRadius;
    y=cy+Math.sin(rot)*outerRadius;
    ctx.lineTo(x,y)
    rot+=step

    x=cx+Math.cos(rot)*innerRadius;
    y=cy+Math.sin(rot)*innerRadius;
    ctx.lineTo(x,y)
    rot+=step
  }
  ctx.lineTo(cx,cy-outerRadius);
  ctx.closePath();
  ctx.lineWidth=2;
  ctx.strokeStyle='blue';
  ctx.stroke();
  ctx.fillStyle='yellow';
  ctx.fill();
}

function getRandomInt(max) {
    return Math.floor(Math.random() * max);
}

function getRandomColor() {
  var characters = "0123456789ABCDEF";
  var color = '#';

  for (var i = 0; i < 6; i++) {
    color += characters[getRandomInt(15)];
  }
  
  return color;
}


async function drawTree (branchRootPos, branchLength, branchAngle, depth) {
  console.log('call')
    if (depth>depthConst) return;
    let newLength =  Math.pow(branchLength, 0.94);

    await new Promise((resolve, reject) => {
     setTimeout(() => resolve(), 0)               //for animation
    });


    // ctx.beginPath();
    // ctx.fillStyle = getRandomColor();
    // ctx.arc(...topBranch, branchLength/30, 0, 2 * Math.PI, false);
    // ctx.fill();

    for (let i=1; i<=NodeCount; i++) {

       let segmRatio = i/(NodeCount+1);
       let nextSegm = [branchRootPos[0]+Math.cos(branchAngle)*(branchLength*segmRatio), branchRootPos[1]+Math.sin(branchAngle)*(branchLength*segmRatio)];
       let prevSegm = [nextSegm[0]-Math.cos(branchAngle)*(branchLength/(NodeCount+1)),nextSegm[1]-Math.sin(branchAngle)*(branchLength/(NodeCount+1))]
        if (depth===2) {
           ballsPositions.push([...prevSegm, branchLength/30])
        }
        ctx.lineWidth = (newLength-(newLength*segmRatio))/15;
       // ctx.strokeStyle = getGreenToRed(newLength/5);
        ctx.strokeStyle = getBrownToGreen(depth);
        ctx.beginPath();
        ctx.moveTo(...prevSegm);
        ctx.lineTo(...nextSegm);
        ctx.stroke();


       await drawTree ([branchRootPos[0]+Math.cos(branchAngle)*(branchLength*segmRatio), branchRootPos[1]+Math.sin(branchAngle)*(branchLength*segmRatio)], newLength-(newLength*segmRatio), branchAngle+Math.PI/3-segmRatio, depth+1);
       await drawTree ([branchRootPos[0]+Math.cos(branchAngle)*(branchLength*segmRatio), branchRootPos[1]+Math.sin(branchAngle)*(branchLength*segmRatio)], newLength-(newLength*segmRatio), branchAngle-Math.PI/3+segmRatio, depth+1);
    }
  console.log('done')
}

async function makeBalls() {
  await drawTree(mainRootPos, mainRootLength, mainRootAngle, 0).then(()=> {
    console.log('Tree ready!')
    console.log(ballsPositions)

    for (ball of ballsPositions) {

      ctx.beginPath();
      ctx.fillStyle = getRandomColor();
      ctx.arc(...ball, 0, 2 * Math.PI, false);
      ctx.fill();

    }

  })
}


 }
</script>